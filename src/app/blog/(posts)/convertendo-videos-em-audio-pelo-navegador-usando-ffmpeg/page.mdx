---
title: Convertendo v√≠deos em √°udio pelo navegador usando FFmpeg e WebAssembly (WASM)
description: Nesse artigo, mostro como aproveitamos o poder do WebAssembly para manipular v√≠deos antes de envia-los ao back-end da aplica√ß√£o.
publishDate: 2024-07-24T11:00:00Z
---

import Image from "next/image";
import audioConversionScreenshot from "./audio-conversion-progress-screenshot.jpg";

## Conte√∫do

## O problema

O Nivo foi criado inicialmente como uma ferramenta para gerar **transcri√ß√µes de v√≠deo-aulas** e, a partir dessas transcri√ß√µes, automatizar o processo de criar t√≠tulos, descri√ß√µes e outros materiais usando **intelig√™ncia artificial**.

Um dos primeiros desafios foi lidar com a **convers√£o de v√≠deos em √°udio**, j√° que muitas APIs dispon√≠veis para transcri√ß√£o suportavam apenas arquivos de √°udio. Al√©m disso, arquivos de √°udio s√£o geralmente 90-95% mais leves que arquivos de v√≠deo, sendo uma op√ß√£o mais eficiente.

### FFmpeg

A primeira ideia foi utilizar o [FFmpeg](https://www.ffmpeg.org/), um projeto open-source que permite manipular arquivos de √°udio e v√≠deo.

Integrado ao Node.js, podemos realizar download, convers√£o e upload utilizando [streams](https://nodejs.org/api/stream.html). Enquanto fazemos o download de um MP4, podemos convert√™-lo para MP3 e, conforme a convers√£o √© feita, fazer o upload do √°udio para o servi√ßo de armazenamento.

## Solu√ß√£o 1: AWS Lambda + FFmpeg

A primeira op√ß√£o foi usar **FFmpeg** hospedado em uma fun√ß√£o serverless (AWS Lambda), que recebia a URL do v√≠deo e salvava o √°udio no storage.

Fun√ß√µes serverless (ou lambdas, como s√£o chamadas na AWS) s√£o c√≥digos que executam sob demanda em ambientes altamente isolados e com recursos limitados.

Sempre que precisamos converter um v√≠deo, chamamos a URL da fun√ß√£o, instanciando um container que realiza a convers√£o e, assim que poss√≠vel, deixa de existir.

Essa solu√ß√£o tem funcionado bem at√© hoje. No entanto, ela gera custos que poderiam ser evitados caso fosse poss√≠vel (_spoiler: √© poss√≠vel_) realizar a convers√£o no client-side (navegador).

Embora atualmente utilizemos **WebAssembly** para a convers√£o de v√≠deo em √°udio, a solu√ß√£o de convers√£o via serverless ainda √© funcional e usada quando os uploads s√£o feitos via API.

_Se voc√™ tiver interesse no c√≥digo dessa fun√ß√£o, me contate no [Twitter](https://x.com/dieegosf)!_

## Solu√ß√£o 2: WebAssembly + FFmpeg

A segunda solu√ß√£o foi usar o projeto [ffmpeg.wasm](https://ffmpegwasm.netlify.app/), que permite executar o FFmpeg diretamente no navegador do usu√°rio via WebAssembly, realizando a convers√£o do v√≠deo sem utilizar recursos do nosso servidor.

Essa op√ß√£o funcionou brilhantemente, e agora cada upload de v√≠deo na plataforma inclui uma etapa autom√°tica de convers√£o para √°udio.

<Image
  className=""
  src={audioConversionScreenshot}
  alt="Captura de tela da plataforma Nivo que destaca a barra de progresso de convers√£o de v√≠deo em √°udio"
  width={768}
  height={290}
/>

Depois de convertido, o √°udio √© enviado para o Cloudflare R2 e utilizado posteriormente para a transcri√ß√£o do v√≠deo.

Agora, vamos ver como ficou o c√≥digo dessa solu√ß√£o.

### Instala√ß√£o das depend√™ncias

Para utilizar o ffmpeg.wasm, precisamos instalar as seguintes depend√™ncias:

```sh
npm i @ffmpeg/ffmpeg @ffmpeg/util
```

_No momento desse post, estou utilizando a vers√£o 0.12.x._

### Setup do ffmpeg.wasm

Primeiro, inicializamos o **ffmpeg.wasm** e usamos uma vari√°vel global para evitar recarregar a biblioteca a cada nova convers√£o.

```ts
import { FFmpeg } from "@ffmpeg/ffmpeg";
import { fetchFile, toBlobURL } from "@ffmpeg/util";

export let ffmpeg: FFmpeg | null = null;

export async function convertVideoToMP3(
  inputFile: File,
  onProgress: (progress: number) => void
): Promise<File> {
  ffmpeg = ffmpeg || new FFmpeg();

  if (!ffmpeg.loaded) {
    const baseURL = "https://unpkg.com/@ffmpeg/core@0.12.6/dist/umd";

    await ffmpeg.load({
      coreURL: await toBlobURL(`${baseURL}/ffmpeg-core.js`, "text/javascript"),
      wasmURL: await toBlobURL(
        `${baseURL}/ffmpeg-core.wasm`,
        "application/wasm"
      ),
    });
  }

  // C√≥digo para convers√£o (abaixo)
}
```

Essa fun√ß√£o recebe o arquivo de origem, representando o v√≠deo carregado pelo usu√°rio, e permite monitorar o progresso da convers√£o com uma fun√ß√£o enviada no segundo par√¢metro.

Usamos um CDN externo (unpkg) para carregar o FFmpeg, pois o arquivo WASM √© pesado (3 MB), evitando o consumo de banda na nossa hospedagem.

### Convers√£o de MP4 em MP3

Agora que temos acesso ao arquivo de v√≠deo, vamos:

1. Utilizar a fun√ß√£o `writeFile` para que o ffmpeg.wasm tenha acesso ao v√≠deo;
2. Atualizar a fun√ß√£o de progresso para a fun√ß√£o recebida no par√¢metro;
3. Converter para MP3 (usamos um bitrate de 32k para criar um arquivo leve);
4. Converter o arquivo para uma inst√¢ncia da classe `File` do JavaScript e retorn√°-la;

```ts
ffmpeg.writeFile(inputFile.name, await fetchFile(inputFile)); // [!code highlight]

const onFFmpegProgress = ({ progress }: { progress: number }) => {
  const progressPercentage = Math.round(progress * 100);

  onProgress(progressPercentage);
};

ffmpeg.on("progress", onFFmpegProgress); // [!code highlight]

const outputId = crypto.randomUUID();

await ffmpeg.exec([
  // [!code highlight:10]
  "-i",
  inputFile.name,
  "-vn",
  "-b:a",
  "32k",
  "-acodec",
  "libmp3lame",
  `${outputId}.mp3`,
]);

const data = (await ffmpeg.readFile(`${outputId}.mp3`)) as Uint8Array;

const audioFileBlob = new Blob([data.buffer], { type: "audio/mpeg" });

const audioFile = new File([audioFileBlob], `${outputId}.mp3`, {
  // [!code highlight:3]
  type: "audio/mpeg",
});

ffmpeg.off("progress", onFFmpegProgress);

return audioFile; // [!code highlight]
```

No momento da escrita deste artigo, o ffmpeg.wasm ainda tem suporte inst√°vel a m√∫ltiplas execu√ß√µes simult√¢neas de comandos do FFmpeg, por isso, realizo a convers√£o de um v√≠deo por vez.

### Upload do arquivo convertido

Depois que o arquivo √© convertido, realizo o upload diretamente para o Cloudflare R2 utilizando [URLs pr√© assinadas](https://docs.aws.amazon.com/pt_br/AmazonS3/latest/userguide/using-presigned-url.html) evitando enviar o arquivo para meu back-end para, s√≥ ent√£o, reenvi√°-lo para o storage.

```ts
await axios.put(uploadUrl, upload.audioFile, {
  headers: { "Content-Type": upload.audioFile.type },
  onUploadProgress(progressEvent) {
    const progress = progressEvent.progress
      ? Math.round(progressEvent.progress * 100)
      : 0;

    console.log("Progresso", progress);
  },
});
```

Para o upload, ainda utilizo o Axios, j√° que a Fetch API n√£o possui suporte para monitorar o progresso do upload (XMLHttpRequest üíú).

## Para o futuro...

A possibilidade de utilizar o FFmpeg no navegador abriu portas para realizar diversas a√ß√µes ‚Äúpesadas‚Äù de convers√£o de v√≠deo e √°udio no navegador, mas pode n√£o ser a solu√ß√£o ideal para sempre.

O ffmpeg.wasm ainda tem muitas limita√ß√µes e uma performance bem inferior (j√° que depende dos recursos da m√°quina do usu√°rio) ao FFmpeg executado em um ambiente ideal, al√©m de haver um limite de 2 GB nos arquivos manipulados.

Abaixo voc√™ pode ver um benchmark de performance com 50 execu√ß√µes comparando a execu√ß√£o da convers√£o em um ambiente isolado comparado ao processo no navegador:

| #      | FFmpeg  | ffmpeg.wasm |
| ------ | ------- | ----------- |
| M√©dia  | 5.2 sec | 128.8 sec   |
| M√°ximo | 5.3 sec | 130.7 sec   |
| M√≠nimo | 5.1 sec | 126.6 sec   |

Provavelmente, a longo prazo, o ideal ser√° mover toda convers√£o de v√≠deos para a primeira solu√ß√£o via AWS Lambda e executar esse trabalho em background, mas com certeza a possibilidade de utilizar WebAssembly tornou o processo mais simples e menos custoso principalmente nesse in√≠cio.
